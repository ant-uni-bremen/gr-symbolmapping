/*
 * Copyright 2020 Johannes Demel
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 */

/***********************************************************************************/
/* This file is automatically generated using bindtool and can be manually edited  */
/* The following lines can be configured to regenerate this file during cmake      */
/* If manual edits are made, the following tags should be modified accordingly.    */
/* BINDTOOL_GEN_AUTOMATIC(0)                                                       */
/* BINDTOOL_USE_PYGCCXML(0)                                                        */
/* BINDTOOL_HEADER_FILE(symbol_mapper.h)                                           */
/* BINDTOOL_HEADER_FILE_HASH(88646303274de52858b1aea0b3f87a44)                     */
/***********************************************************************************/

#include <pybind11/complex.h>
#include <pybind11/numpy.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

namespace py = pybind11;

#include <cstdint>

#include <symbolmapping/symbol_mapper.h>


void bind_symbol_mapper(py::module& m)
{
    m.def("lin2db", &lin2db);
    m.def("db2lin", &db2lin);
    py::class_<SymbolMapping>(m, "SymbolMapping")

        .def(py::init<unsigned, std::string>(),
             py::arg("constellation_order") = 2,
             py::arg("cstl_type") = std::string("GRAY"))
        .def("constellationOrder", &SymbolMapping::constellationOrder)
        .def("constellationSize", &SymbolMapping::constellationSize)
        .def("constellationType", &SymbolMapping::constellationType)
        .def("setConstellationOrder", &SymbolMapping::setConstellationOrder)
        .def("constellation",
             [](SymbolMapping& self) {
                 auto c = self.constellation();
                 return py::array(c.size(), c.data());
             })

        .def("map_to_constellation",
             [](SymbolMapping& self,
                const py::array_t<uint8_t, py::array::c_style | py::array::forcecast>
                    array) {
                 py::buffer_info inb = array.request();
                 if (inb.ndim != 1) {
                     throw std::runtime_error("Only ONE-dimensional vectors allowed!");
                 }
                 auto result = py::array_t<fcmplx>(inb.size / self.constellationOrder());
                 py::buffer_info resb = result.request();

                 self.map_to_constellation(
                     (fcmplx*)resb.ptr, (uint8_t*)inb.ptr, inb.size);
                 return result;
             })
        .def(
            "calculate_ln_probabilities",
            [](SymbolMapping& self,
               const py::array_t<fcmplx, py::array::c_style | py::array::forcecast> array,
               const float snr_db) {
                py::buffer_info inb = array.request();
                if (inb.ndim != 1) {
                    throw std::runtime_error("Only ONE-dimensional vectors allowed!");
                }
                auto result = py::array_t<float>(inb.size * self.constellationSize());
                py::buffer_info resb = result.request();

                self.calculate_ln_probabilities(
                    (float*)resb.ptr, (fcmplx*)inb.ptr, inb.size, snr_db);
                return result;
            })
        .def(
            "demap_llrs",
            [](SymbolMapping& self,
               const py::array_t<fcmplx, py::array::c_style | py::array::forcecast> array,
               const float snr_db) {
                py::buffer_info inb = array.request();
                if (inb.ndim != 1) {
                    throw std::runtime_error("Only ONE-dimensional vectors allowed!");
                }
                auto result = py::array_t<float>(inb.size * self.constellationOrder());
                py::buffer_info resb = result.request();

                self.demap_llrs((float*)resb.ptr, (fcmplx*)inb.ptr, inb.size, snr_db);
                return result;
            })
        .def(
            "demap_llrs_vec",
            [](SymbolMapping& self,
               const py::array_t<fcmplx, py::array::c_style | py::array::forcecast> array,
               const py::array_t<float, py::array::c_style | py::array::forcecast>
                   snrs_lin) {
                py::buffer_info inb = array.request();
                py::buffer_info snrb = snrs_lin.request();
                if (inb.ndim != 1) {
                    throw std::runtime_error("Only ONE-dimensional vectors allowed!");
                }
                if (inb.size != snrb.size) {
                    throw std::runtime_error(
                        "Symbol vector size MUST be equal to SNR vector size!");
                }

                auto result = py::array_t<float>(inb.size * self.constellationOrder());
                py::buffer_info resb = result.request();

                self.demap_llrs_vec(
                    (float*)resb.ptr, (fcmplx*)inb.ptr, (float*)snrb.ptr, inb.size);
                return result;
            })

        ;
}
